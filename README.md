# PyExperimenter
The PyExperimenter is a tool for the automatic execution of various experiments. The user can create a function
that run one single experiment (we call this function `own_function`, but any function name is possible). The experiment itself,
which is defined by its parameters, is then automatically executed by passing the parameters to the `own_function` and writing the
results in a database. Errors that occur during execution are also captured by the PyExperimenter and written to the database.


## Installation and configuration
In order to install the package via pip use the command
```
pip install py_experimenter
```

### Configuration file
The configuration file is used to define the database credentials, as well as the settings for PyExperimenter.
In addition, the user can create his own configurations, which are passed to the executing function during execution.

Each configuration file consists of three sections: `DATABASE`, `PY_EXPERIMENTER` and `CUSTOM`. Note that the sections `DATABASE` and `PY_EXPERIMENTER`
are mandatory while the `CUSTOM` section is optional.
In the following we will go through these sections and go into more detail about the individual configuration parameters.

####DATABASE
The database section contains the credentials for the database where the experiment parameters, results, potential errors and meta information of the experiments are written.
```
[DATABASE]
host=<hostname>
user=<username>
database=<databasename>
password=<password>
table=<tablename>
```
Note that the table is automatically generated by PyExperimenter.
In the configuration file you should therefore only enter the desired name.

####PY_EXPERIMENTER
In this section of the configuration, the experiment is defined.
```
[PY_EXPERIMENTER]
cpu.max = <number_of_cpus>

keyfields = keyfieldname1, keyfieldname2:int(3)

keyfieldname1=A,B,C
keyfieldname2=1,2,3

resultfields = resultfield1, resultfield2:LONGTEXT
```
First, the number of CPUs available to run the experiments in parallel must be specified.

The `keyfields` define all parameter names that are needed for the experiment.
These parameters are passed as parameters to the `own_function` to be executed.
To determine all possible values for each of the `keyfields`, these must also be defined in the configuration.
To do this, all possible values are assigned to the respective `keyfield`, separated by commas.

The `resultfields` define all names of the results of the experiment.
These must be returned by the `own_function` to be executed.

Note that both the `keyfields` and the `resultfields` can be assigned a data type.
These must be defined in SQL notation separated from the field name by a colon.
If no data type is explicitly specified, `VARCHAR(255)` is used.

####CUSTOM
In the last (optional) section you can define your own configurations. These are passed to the `own_function` to be executed, where they can then be used.
```
[CUSTOM]
custom.setting1=<value>
custom.setting2=<value>
```

An example of a configuration file can be found in `config/example_config.cfg`.

## How should the function to be executed look like?
To use the PyExperimenter for your experiments, you need to create a function (again, we call this function `own_function`) with 3 parameters.
This function will be called by the PyExperimenter to process each instance of the experiment.
```
def own_function(parameters: dict, result_processor: ResultProcessor, custom_config: dict):
```
The first parameter `parameters: dict` contains a dictionary with `keyfieldname: value` entities. You can use the parameters
in you experiment by calling the dictionary with the keyfieldname.

The second parameter `result_processor` is an object of class `ResultProcessor` which process the results
and writes them to the database. In order to write one (or multiple) result(s) to the database, create a
dictionary of resultfieldname and value pairs. After that call the `process_results()` method of the `ResultProcessor`
and pass the dictionary as an argument to write the results to the database. 
```
results = {'resultfield1': value1, 'resultfield2': value2}

result_processor.process_results(results)
```
You can call this method multiple times during the execution of you experiment. Note that you can only write to resultfields
defined in the configuration. If a dictionary with other keys not defined in the configuration file, the results will not be
written to the database.

The third parameter `custom_config: dict` passes all custom configurations defined in the `CUSTOM` section in the configuration
file to the experiment. Note that this parameter is needed even if you have not set your custom configurations.

## How to run the PyExperimenter
To run the PyExperimenter you need to initialize a `PyExperimenter` object:
```python
import PyExperimenter

# initialize the PyExperiementer
experimenter = PyExperimenter()
```
If you don't use the default path of the configuration file, you can pass a different path to the file
in the constructor of the PyExperimenter by using the parameter `config_path`.

### Fill the table with parameters
The `fill_table()` method will create a new table in the database (if it not already exist) and fill
it with all combinations of values defined for the keyfields in the configuration file. Note that only
combinations that no duplicates will be created. If a combination already exist in the table, it will not
be inserted again. After a new parameter combination was added to the table, the status of that row will
be set to `created`.
```python
# create table in database and fill it with all parameter combinations
experimenter.fill_table()
```

#### Set custom parameter combinations
If your experiment setup does not need all combinations of parameters, you can pass a list of parameter-combinations
to the `fill_table()` method by using the parameter `own_parameters`. 
```python
# create table in database and fill it with specified parameter combinations
experimenter.fill_table(own_paramerters=[{'keyfieldname1': '1', 'keyfieldname2': 42},
                                         {'keyfieldname1': '2', 'keyfieldname2': 42},
                                         {'keyfieldname1': '3', 'keyfieldname2': 42},])
```
Since the values defined in the configuration for each keypad are ignored when using this parameter,
they can also be omitted there. Nevertheless, the names of the keyfields must be defined in the configuration.
If you want to use all combinations of values from the configuration file, as well as your own additional combinations,
you can call the `fill_table` once with and once without `own_parameters`.
```python
# create table in database and fill it with all parameter combinations
experimenter.fill_table()

# fill table with specified parameter combinations
experimenter.fill_table(own_paramerters=[{'keyfieldname1': '1', 'keyfieldname2': 42},
                                         {'keyfieldname1': '2', 'keyfieldname2': 42},
                                         {'keyfieldname1': '3', 'keyfieldname2': 42},])
```

### Execute experiments
The `execute(approach)` method will only run all experiments from the database table with status `created`.
This ensures that each experiment is executed only once. After an experiment is started, the status of this
experiment is set to `running`. The experiments will be run in parallel if the number of cpus is greater one
in the configuration. If the experiment finished without any errors, the status will be set to `done`.
However, if errors occur during execution, the status changes to `error`, and the respective error message
is written to the database. In both cases, after the termination of one experiment, the next one is executed.
```python
# run the experiement for all experiement (parameter combinations from the database)
experimenter.execute(own_function)
```
After all experiments have been executed, the user can check the database to see if any errors occurred during execution.
If this is the case, he can fix the error, delete the experiments where the error occurred from the database
and run the `PyExperimenter` again. The deleted experiments will then be automatically recreated and executed.
All already successfully executed experiments are not affected by this.

#### Execute specific number of experiments / Execute in random order
You can specify a specific number of experiments to execute as well as if the experiments should
be execute in a random order. 
```python
experimenter.execute(own_function, max_experiments=10, random_order=True)
```

### Database entries
All experiments are written to the database, defined in the configuration file. In the following we will see how
such a database table generated by PyExperimenter could look like. The first columns are the keyfields followed by
the resultfields, defined in the configuration file. These columns are followed by the `status` and the `machine`,
the former indicating the status of the experiment and the latter the id of the machine on which the experiment was run.
Note that with the configuration `cpu.max = 1`, the experiments are run on only one machine,
so the machine id is identical for each experiment. The status values for the `status` column are as follows:
- `created`: All parameters for the experiment instance are defined, and the instance is ready for execution.
- `running`: The instance of the experiment is currently in execution.
- `done`: The execution of the experiment instance is finished, and the results are written in the database without any errors.
- `error`: An error occurred during execution.

This is followed by the `creation_date`,`start_date` and `end_date` columns, which contain the creation, start and end times. 
The last column contains the error message of the exercise. If no error occurred, this column contains the entry `NULL`.
